import jinja2
import os
from datetime import datetime

from .utils import construct_function_call, Variable


OBJECT_TEMPLATE = '''# {{ cls.filename }}
# Auto-generated by altair_parser {{ date }}
{%- for import in cls.imports %}
{{ import }}
{%- endfor %}

class {{ cls.classname }}({{ cls.baseclass }}):
    """{{ cls.classname }} class

    Attributes
    ----------
    {%- for (name, prop) in cls.wrapped_properties().items() %}
    {{ name }} : {{ prop.type }}
        {{ prop.description }}
    {%- endfor %}
    """
    {%- for (name, prop) in cls.wrapped_properties().items() %}
    {{ name }} = {{ prop.trait_code }}
    {%- endfor %}
'''


class TraitCodeExtractor(object):
    """Base class for trait code extractors.

    An ordered list of these is passed to JSONSchema, and they are used to
    extract appropriate trait codes.
    """
    #def __init__(self, schema, typecode=None):
    #    self.schema = schema
    #    self.typecode = typecode or schema.type

    def check(self):
        raise NotImplementedError()

    def trait_code(self, **kwargs):
        raise NotImplementedError()

class SimpleTraitCode(TraitCodeExtractor):
    simple_types = ["boolean", "null", "number", "integer", "string"]
    classes = {'boolean': 'jst.JSONBoolean',
               'null': 'jst.JSONNull',
               'number': 'jst.JSONNumber',
               'integer': 'jst.JSONInteger',
               'string': 'jst.JSONString'}
    validation_keys = {'number': ['minimum', 'exclusiveMinimum',
                                  'maximum', 'exclusiveMaximum',
                                  'multipleOf'],
                       'integer': ['minimum', 'exclusiveMinimum',
                                   'maximum', 'exclusiveMaximum',
                                   'multipleOf']}
    def check(self, schema, typecode=None):
        typecode = typecode or schema.type
        return typecode in self.simple_types

    def trait_code(self, schema, typecode=None, **kwargs):
        typecode = typecode or schema.type
        cls = self.classes[typecode]
        keys = self.validation_keys.get(typecode, [])
        kwargs.update({key: schema[key] for key in keys if key in schema})
        return construct_function_call(cls, **kwargs)


class CompoundTraitCode(TraitCodeExtractor):
    simple_types = SimpleTraitCode.simple_types
    def check(self, schema, typecode=None):
        typecode = typecode or schema.type
        return isinstance(typecode, list)

    def trait_code(self, schema, typecode=None, **kwargs):
        typecode = typecode or schema.type
        for typ in typecode:
            assert typ in self.simple_types
        if 'null' in typecode:
            kwargs['allow_none'] = True
        typecode = [typ for typ in typecode if typ != 'null']
        simple = SimpleTraitCode()
        if len(typecode) == 1:
            return simple.trait_code(schema, typecode[0], **kwargs)
        else:
            item_kwargs = {key:val for key, val in kwargs.items()
                           if key not in ['allow_none', 'allow_undefined']}
            arg = "[{0}]".format(', '.join(simple.trait_code(schema, typ, **item_kwargs)
                                           for typ in typecode))
            return construct_function_call('jst.JSONUnion', Variable(arg), **kwargs)


class RefTraitCode(TraitCodeExtractor):
    def check(self, schema, typecode=None):
        return '$ref' in schema

    def trait_code(self, schema, typecode=None, **kwargs):
        ref = schema.get_reference(schema['$ref'])
        if ref.is_object:
            return construct_function_call('jst.JSONInstance',
                                           Variable(ref.classname),
                                           **kwargs)
        else:
            ref = ref.copy()  # TODO: maybe can remove this?
            ref.metadata = schema.metadata
            return ref.trait_code


class EnumTraitCode(TraitCodeExtractor):
    def check(self, schema, typecode=None):
        return 'enum' in schema

    def trait_code(self, schema, typecode=None, **kwargs):
        return construct_function_call('jst.JSONEnum', schema["enum"], **kwargs)


class ArrayTraitCode(TraitCodeExtractor):
    def check(self, schema, typecode=None):
        return schema.type == 'array'

    def trait_code(self, schema, typecode=None, **kwargs):
        # TODO: implement items as list and additionalItems
        items = schema['items']
        if 'minItems' in schema:
            kwargs['minlen'] = schema['minItems']
        if 'maxItems' in schema:
            kwargs['maxlen'] = schema['maxItems']
        if 'uniqueItems' in schema:
            kwargs['uniqueItems'] = schema['uniqueItems']
        if isinstance(items, list):
            raise NotImplementedError("'items' keyword as list")
        else:
            itemtype = schema.make_child(items).trait_code
        return construct_function_call('jst.JSONArray', Variable(itemtype),
                                       **kwargs)


class AnyOfTraitCode(TraitCodeExtractor):
    def check(self, schema, typecode=None):
        return 'anyOf' in schema

    def trait_code(self, schema, typecode=None, **kwargs):
        children = [Variable(schema.make_child(sub_schema).trait_code)
                    for sub_schema in schema.schema['anyOf']]
        return construct_function_call('jst.JSONAnyOf', Variable(children),
                                       **kwargs)


class OneOfTraitCode(TraitCodeExtractor):
    def check(self, schema, typecode=None):
        return 'oneOf' in schema

    def trait_code(self, schema, typecode=None, **kwargs):
        children = [Variable(schema.make_child(sub_schema).trait_code)
                    for sub_schema in schema.schema['oneOf']]
        return construct_function_call('jst.JSONOneOf', Variable(children),
                                       **kwargs)


class AllOfTraitCode(TraitCodeExtractor):
    def check(self, schema, typecode=None):
        return 'allOf' in schema

    def trait_code(self, schema, typecode=None, **kwargs):
        children = [Variable(schema.make_child(sub_schema).trait_code)
                    for sub_schema in schema.schema['allOf']]
        return construct_function_call('jst.JSONAllOf', Variable(children),
                                       **kwargs)


class NotTraitCode(TraitCodeExtractor):
    def check(self, schema, typecode=None):
        return 'not' in schema

    def trait_code(self, schema, typecode=None, **kwargs):
        not_this = schema.make_child(schema['not']).trait_code
        return construct_function_call('jst.JSONNot', Variable(not_this),
                                       **kwargs)


class JSONSchema(object):
    """A class to wrap JSON Schema objects and reason about their contents"""
    object_template = OBJECT_TEMPLATE
    __draft__ = 4

    _cached_references = {}
    simple_types = ["boolean", "null", "number", "integer", "string"]
    valid_types = simple_types + ["array", "object"]
    traitlet_map = {'array': {'cls': 'jst.JSONArray'},
                    'boolean': {'cls': 'jst.JSONBoolean'},
                    'null': {'cls': 'jst.JSONNull'},
                    'number': {'cls': 'jst.JSONNumber',
                               'validation_keys': ['minimum', 'maximum',
                                                   'exclusiveMinimum',
                                                   'exclusiveMaximum',
                                                   'multipleOf']},
                    'integer': {'cls': 'jst.JSONInteger',
                                'validation_keys': ['minimum', 'maximum',
                                                    'exclusiveMinimum',
                                                    'exclusiveMaximum',
                                                    'multipleOf']},
                    'string': {'cls': 'jst.JSONString'},
                   }
    attr_defaults = {'title': '',
                     'description': '',
                     'properties': {},
                     'definitions': {},
                     'default': None,
                     'examples': {},
                     'type': 'object',
                     'required': []}
    basic_imports = ["import traitlets as T",
                     "from . import jstraitlets as jst",
                     "from .baseobject import BaseObject"]

    def __init__(self, schema, context=None, parent=None, name=None, metadata=None):
        self.schema = schema
        self.parent = parent
        self.name = name
        self.metadata = metadata or {}

        # if context is not given, then assume this is a root instance that
        # defines its context
        self.context = context or schema

    def __getitem__(self, key):
        return self.schema[key]

    def __contains__(self, key):
        return key in self.schema

    def copy(self):
        return self.__class__(schema=self.schema, context=self.context,
                              parent=self.parent, name=self.name,
                              metadata=self.metadata)

    def make_child(self, schema, name=None, metadata=None):
        """
        Make a child instance, appropriately defining the parent and context
        """
        return self.__class__(schema, context=self.context,
                              parent=self, name=name, metadata=metadata)

    def __getattr__(self, attr):
        if attr in self.attr_defaults:
            return self.schema.get(attr, self.attr_defaults[attr])
        raise AttributeError(f"'{self.__class__.__name__}' object "
                             f"has no attribute '{attr}'")

    @property
    def is_root(self):
        return self.context is self.schema

    @property
    def is_trait(self):
        return self.type != 'object' and not self.is_reference

    @property
    def is_object(self):
        return self.type == 'object' and not self.is_reference

    @property
    def is_reference(self):
        return '$ref' in self.schema

    @property
    def classname(self):
        if self.name:
            return self.name
        elif self.is_root:
            return "RootInstance"
        elif self.is_reference:
            return self.schema['$ref'].split('/')[-1]
        else:
            raise NotImplementedError("Anonymous class name")

    @property
    def modulename(self):
        return self.classname.lower()

    @property
    def filename(self):
        return self.modulename + '.py'

    @property
    def baseclass(self):
        return "BaseObject"

    @property
    def import_statement(self):
        return f"from .{self.modulename} import {self.classname}"

    @property
    def imports(self):
        imports = []
        imports.extend(self.basic_imports)
        for obj in self.wrapped_properties().values():
            if obj.is_reference:
                ref = self.get_reference(obj.schema['$ref'])
                if ref.is_object:
                    imports.append(ref.import_statement)
        return imports

    @property
    def module_imports(self):
        imports = []
        for obj in self.wrapped_definitions().values():
            if obj.is_object:
                imports.append(obj.import_statement)
        return imports

    def wrapped_definitions(self):
        """Return definition dictionary wrapped as JSONSchema objects"""
        return {name.lower(): self.make_child(schema, name=name)
                for name, schema in self.definitions.items()}

    def wrapped_properties(self):
        """Return property dictionary wrapped as JSONSchema objects"""
        return {name: self.make_child(val, metadata={'required': name in self.required})
                for name, val in self.properties.items()}

    def get_reference(self, ref, cache=True):
        """
        Get the JSONSchema object for the given reference code.

        Reference codes should look something like "#/definitions/MyDefinition"

        By default, this will cache objects accessed by their ref code.
        """
        if cache and ref in self._cached_references:
            return self._cached_references[ref]

        path = ref.split('/')
        name = path[-1]
        if path[0] != '#':
            raise ValueError(f"Unrecognized $ref format: '{ref}'")
        try:
            schema = self.context
            for key in path[1:]:
                schema = schema[key]
        except KeyError:
            raise ValueError(f"$ref='{ref}' not present in the schema")

        wrapped_schema = self.make_child(schema, name=name)
        if cache:
            self._cached_references[ref] = wrapped_schema
        return wrapped_schema

    def _simple_trait_code(self, typecode, kwargs):
        validator = SimpleTraitCode()
        assert validator.check(self, typecode=typecode)
        return validator.trait_code(self, typecode=typecode, **kwargs)

    def _compound_trait_code(self, typecode, kwargs):
        validator = CompoundTraitCode()
        assert validator.check(self, typecode=typecode)
        return validator.trait_code(self, typecode=typecode, **kwargs)

    def _ref_trait_code(self, typecode, kwargs):
        validator = RefTraitCode()
        assert validator.check(self, typecode=typecode)
        return validator.trait_code(self, typecode=typecode, **kwargs)

    def _enum_trait_code(self, typecode, kwargs):
        validator = EnumTraitCode()
        assert validator.check(self, typecode=typecode)
        return validator.trait_code(self, typecode=typecode, **kwargs)

    def _array_trait_code(self, typecode, kwargs):
        validator = ArrayTraitCode()
        assert validator.check(self, typecode=typecode)
        return validator.trait_code(self, typecode=typecode, **kwargs)

    def _anyOf_trait_code(self, typecode, kwargs):
        validator = AnyOfTraitCode()
        assert validator.check(self, typecode=typecode)
        return validator.trait_code(self, typecode=typecode, **kwargs)

    def _allOf_trait_code(self, typecode, kwargs):
        validator = AllOfTraitCode()
        assert validator.check(self, typecode=typecode)
        return validator.trait_code(self, typecode=typecode, **kwargs)

    def _oneOf_trait_code(self, typecode, kwargs):
        validator = OneOfTraitCode()
        assert validator.check(self, typecode=typecode)
        return validator.trait_code(self, typecode=typecode, **kwargs)

    def _not_trait_code(self, typecode, kwargs):
        validator = NotTraitCode()
        assert validator.check(self, typecode=typecode)
        return validator.trait_code(self, typecode=typecode, **kwargs)

    @property
    def trait_code(self):
        """Create the trait code for the given typecode"""
        typecode = self.type
        if self.metadata.get('required', False):
            kwargs = {'allow_undefined': False}
        else:
            kwargs = {}

        # TODO: handle multiple entries...

        if "not" in self.schema:
            return self._not_trait_code(typecode, kwargs)
        elif "$ref" in self.schema:
            return self._ref_trait_code(typecode, kwargs)
        elif "anyOf" in self.schema:
            return self._anyOf_trait_code(typecode, kwargs)
        elif "allOf" in self.schema:
            return self._allOf_trait_code(typecode, kwargs)
        elif "oneOf" in self.schema:
            return self._oneOf_trait_code(typecode, kwargs)
        elif "enum" in self.schema:
            return self._enum_trait_code(typecode, kwargs)
        elif typecode in self.simple_types:
            return self._simple_trait_code(typecode, kwargs)
        elif typecode == 'array':
            return self._array_trait_code(typecode, kwargs)
        elif typecode == 'object':
            raise NotImplementedError("Anonymous Objects")
        elif isinstance(typecode, list):
            return self._compound_trait_code(typecode, kwargs)
        else:
            raise ValueError(f"unrecognized type identifier: {typecode}")

    def object_code(self):
        """Return code to define a BaseObject for this schema"""
        now = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
        return jinja2.Template(self.object_template).render(cls=self, date=now)

    def module_spec(self):
        """Return the JSON specification of the module

        This can be passed to ``altair_parser.utils.load_dynamic_module``
        or to ``altair_parser.utils.save_module``

        """
        assert self.is_root
        submodroot = self.classname.lower()

        modspec = {
            'jstraitlets.py': open(os.path.join(os.path.dirname(__file__),
                                   'src', 'jstraitlets.py')).read(),
            'baseobject.py': open(os.path.join(os.path.dirname(__file__),
                                  'src', 'baseobject.py')).read(),
            self.filename: self.object_code()
        }

        modspec['__init__.py'] = '\n'.join([self.import_statement]
                                            + self.module_imports)

        modspec.update({schema.filename: schema.object_code()
                        for schema in self.wrapped_definitions().values()
                        if schema.is_object})

        return modspec
